 
1. Создать файл `program.java`. Создасться класс `public class program`:

    public class program {
        } 

 Это минимальная ед-ца в контексте ЯП Джава.

Нужно определить место, с которого буде стартовать программа - это наз точка входа. Она определяется функцией/методом `main()`:

    static public void main(String[] args) {       
    }

`String[] args` - обязятельная часть.

Это минимальная программа джава:

    public class program {
        static public void main(String[] args) {
        
        }
    }

Сниппеты. Начинаешь писать `class`, а VSC подскажет выбор, выбрать 2-й. Далее на 2-й строке написать `main`, выбрать 1-й пункт и сформируется метод `main(String[] args)` самостоятельно.

    System.out.println("bye world"); - простой код вывода в терминал

Через сниппет. Начать писать `sysout` + `Enter`, в VSC и получится сразу `System.out.println();`.

Способы запуска кода:

1. Кнопка "треугольник" в верхнем правом углу VSC.
2. В терминале:

    java program.java - MacOS

    javac program.java  - linux: create class
    java program        - linux: run program

Комментарии:

    /*
    * comment
    */

Простой комментарий

    //

Структура простой программы:

    /**
    * Program
    */
    public class Program {
        public static void main(String[] args) {
            System.out.println("Goodbye, World");
        }
    }

## Типы данных и переменные
Основы Java и C# - +- одинаковые.
Типы данных:
1. примитивные:
    a) boolean - логический;<br>
    b) int, short, long - целочисленные;<br> 
    c) float, double - вещественные;<br>
    d) Char - символьный, который неявно является на самом деле числовым;<br>
     и т.д.. 
2. ссылочные - все что относится к классам и интерфейсам. 
Когда дело касается тонкостей работы с ссылочными типами, то они более детально будут разбираться в контексте ООП. Пока из ссылочного типа будут только массивы.

Создание переменной:

    <тип><индентификатор>; - объявление переменной
    <индентификатор> = <значение>; - инициализация переменной

Обычно делается так:

    <тип><индентификатор> = <значение>;

> Без инициализации переменной - программа не скомпелируется!

Пример:

    String s = null; - так можно сделать, это пустая ссылка

Пустая ссылка - особенности хранения данных в памяти. Это будет в ООП.

### Примитивные типы, целочисленные:

    short age = 10;
    int salary = 123456;
    int i = 23_123_34;          // так можно разделять разряды для наглядности
    System.out.println(age);    // 10
    System.out.println(salary); // 123456

### Примитивные типы, вещественные:

    float e = 2.7f;
    double pi = 3.1415;
    double pi = 3.1415D; - необязательно так
    System.out.println(e);    //2.7
    System.out.println(pi);    //3.1415

> Суффикс `f` для `float` использовать обязательно!!! Т.к. неявное преобразование в `float` не работает:

    float e = 123.45; - неявно воспиримется как `double` - неявная конвертация не сработает.
    float e = 123.45f; - только так

> Суффикс `D` для `double` можно не делать, потому-что числовое значение воспринимается как `double`.

### Тип данных `Char`.
 `Char` - определяет отдельный символ:

    char ch = '1';
    System.out.println(Character.isDigit(ch)); //true
    ch = 'a';
    System.out.println(Character.isDigit(ch)); //false

>!!!Внимание. Нужно быть внимательным с `char`.

    ch = '{';
    System.out.println(ch); // {
    ch = 123;
    System.out.println(ch); // {

Если в `char` положить `123`, то произойдет неявное перобразование одного типа `число` в `символ` и в `ch` будет не число `123` храниться, а символ `{`.

>
> Неявное преобразование - когда не указывается суффикс!

Преобразование `int` в `double` возможно:

    int a = 15;
    double d = a;
    a = d; - так просто не получится, нужно использовать перобразование.

Потому-что в `int` 4 байта и целый тип, а `double` - это 8 байт и вдобавок вещественный тип.

### Boolean.

        boolean falg1 = 123 <= 234;
        System.out.println(falg1);      // true
        boolean falg2 = 123 >= 234;
        System.out.println(falg2);      // true
        boolean falg3 = falg1 ^ falg2;
        System.out.println(falg3);

Логические операторы: AND (`&&`), OR (`||`). Побитовые: (`&`), (`|`).

Разделяющая ИЛИ-ИЛИ в Java (`^`), или разделительная дизюнкция. Возвращает ИСТИНУ тогда и только тогда, когда строго одни из значений ИСТИНА.
    
    true ^ false // true
    true ^ true // false

### String.

Может показаться, что  `String` - примитивный тип данных, но в Java это не так.

### Неявная типизация.
Можно явно указать тип данных, например, `boolean`:

    boolean f = true;
    int a = 123;

Но в тоже время можно:

    var i = 123;

Хорошо ли это, или плохо? Это классический подход, не всегда можно точно определить тип данных. Когда будет компилиляция, то вместо `var` будет подставлен наиболее вероятный тип данных.

> Внимание! Любой метод в Java должен быть частью класса.

Тип данных можно получить след методом:

    public static void main(String[] args) {
        var a = 123;
        System.out.println(getType(a));
    }

    static String getType(Object o) {
        return o.getClass().getSimpleName();
    }

`static String getType(Object o) { }` - коротко, это статический член класса.

`Object` - тип.

### Классы-обертки.

    Примитив    -   Обертка
    int         -   Integer
    short       -   Short
    long        -   Long
    byte        -   Byte
    float       -   Float
    double      -   Double
    char        -   Character
    boolean     -   Boolean

Если при присвоении указать `int a = 1213;` - то все будет нормально работать. Но если нужны детали работы с этой переменной, то возникнут проблемы, например, узнать максимально возможное значение переменной `int`:

    System.out.println(int.);      //  технически можно было бы, но не сработает
    System.out.println(Integer.MAX_VALUE);  // так доступны методы класса

Например, нужно провести проверку символа на принадлежность чего-то: числу, букве, большой букве, превратить в большую букву.

> Через точку `.`, например, `Character.` обращение к членам того класса с которым мы работаем.

    char b = '2';
    System.out.println(Character.isDigit(b)); // true

Пример со строкой. Например, получить символ строки:

    String s = "qwer";
    s[1] = ...;         // так обращение к символу в Java  не сработает
    s.length();         // длина строки
    s.charAt(1);        // w

### Операции Java.

* Присваивание: =
* Арифметические: *, /, +, -, %, ++ (инкремент), -- (декремент)
* Операции сравнения: <, >, ==, !=, >=, <=
* Логические операции: ||, &&, ^, !
* Побитовые операции: <<, >>, &, |, ^

[10. Java – Основные операторы языка. Тернарный оператор или условный оператор (?:)](https://proglang.su/java/operators)

> Внимание! Стоит попробовать делить типы данных: `int` и `double`; потренироваться. Как себя ведут эти операции в контексте Java?

    int a = 123;
    a++;
    System.out.println(a);  // 124

А так:

    a = 123;
    System.out.println(a++);    // 123
    System.out.println(a);      // 124

Т.е в строке `System.out.println(a++);` сначала выполняется команда, а потом `a` увеличивается на 1-цу.
Или по другому, приоритет операции инкремента (постфиксного) `a++` ниже приоритета операции вывода на консоль.

Инкремент (префиксный) можно также написать:
    
    a = 125;
    System.out.println(++a);    // 126
    System.out.println(a);      // 126

> Теперь приоритет выполнения операции инкремента выше чем операция вывода в консоль.

#### Недобросовестные интервьюеры.

Спрашивают:

    a = 123;
    a = a-- - --a;
    System.out.println(a);  // 2
    a = --a - a--;
    System.out.println(a);  // 0
    a = --a-a--;
    System.out.println(a);  // 0

> Я не понял, почему `а = 2`? У меня `a = 1`. [Объяснение](https://skillbox.ru/media/base/inkrement_i_dekrement_v_java/).

Объяснение `a = a-- - --a;`. Порядок вычисления операций в Java слева направо.
1. на место уменьшаемого `а--` подставляется 123;
2. а уменьшается на 1-цу;
3. в вычитаемом `--a` сначала вычитается 1-ца: 122 - 1 = 121;
4. теперь выражение перед операцией вычитания имеет вид `a = 123 - 121`, а = 2.

>  Тогда входным значением переменной для вычисления каждого последующего инкремента или декремента будет значение этой переменной после вычисления предыдущего инкремента или декремента.
То есть инкременты/декременты в выражении обрабатываются не одновременно, а по очереди, порядок в которой определяется ассоциативностью и приоритетом этих операторов в Java. 

#### Операции сравнения.
Классические операции сравнения для чисел:

    boolean f = 123 > 234;
    System.out.println(f);  // false

    boolean f = 123 <= 234;
    System.out.println(f);  // true
    
    boolean f = 123 != 234;
    System.out.println(f);  // true

> Для ссылочных типов данных операции сравнения не так очевидны. Не все подряд так можно сравнивать.

#### Логические операции.
[Логические операторы в Java](https://javarush.ru/groups/posts/logicheskie-operacii-v-java)

* ||, OR-  дизъюнкция.
* &&, AND - конъюнкция
* ^, XOR - строгая дизъюнкция, исключающее ИЛИ. Истина тогда, когда строго одно из должно быть истина.

> По простому, если один оператор `&` или `|` - проверяется оба выражения, и левое, и правое. При условных операторах `&&` и `||` - правое выражение проверяется только если `левое = true`.

Приоритет логических операторов:
1. !
2. &
3. ^
4. |
5. &&
6. ||

#### Побитовые операции.

Побитовые операции, или побитовые сдвиги используются редко.

    int a = 8;      // 1000 - в битах
    // a = a << 1;  // 10000
    // System.out.println(a);   // 16
    System.out.println(a << 1); // 16
    
    a = 18;      // 10010 - в битах
    // a = a >> 1;  // 1001
    // System.out.println(a);   // 9
    System.out.println(a >> 1); // 9

Задачка на собесе:

    int b = 5;
    int c = 2;
    System.out.println(a | b);  // 7
    // 101 - 5
    // 010 - 2
    // 111 - 7

    System.out.println(b & c);  // 7
    // 101 - 5
    // 010 - 2
    // 000 - 0
    
    System.out.println(b ^ c);  // 7
    // 101 - 5
    // 010 - 2
    // 000 - 0

    boolean d = true;
    boolean e = true;
    System.out.println(d & e);  // true
    System.out.println();
    
    String s = "qwer"; // длина 4, 0..3
    boolean i = s.length() >= 5 && s.charAt(4) == '1'; // false && false
    System.out.println(i); // false
    
    s = "qwwe1"; // длина 5, 0..4
    i = s.length() >= 5 && s.charAt(4) == '1'; // true && true
    System.out.println(i); // true
    i = s.length() >= 5 & s.charAt(4) == '1'; // true && true
    System.out.println(i); // true
    
    s = "qww1"; // длина 4, 0..3
    i = s.length() >= 5 & s.charAt(4) == '1'; // false && false
    System.out.println(i); // Exception
55:46



[Javarush. Приоритет операторов.](https://javarush.ru/quests/lectures/questmultithreading.level01.lecture01)